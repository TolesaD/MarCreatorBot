// ALWAYS load dotenv first (won't hurt if file doesn't exist)
try {
  require('dotenv').config();
} catch (e) {
  console.log('📝 No .env file found, using environment variables only');
}

console.log('🔍 DEBUGGING STARTUP ON RAILWAY');
console.log('================================');

// ========== REMOVE THE EARLY ENVIRONMENT CHECK ==========
// Railway loads variables AFTER the application starts
// Don't check them immediately - wait for initialization

// Let's just log what we have without failing
console.log('📋 Initial Environment check:');
console.log('   NODE_ENV:', process.env.NODE_ENV || 'not set');
console.log('   PORT:', process.env.PORT || 'not set');
console.log('   HOST:', process.env.HOST || 'not set');
console.log('   RAILWAY_ENVIRONMENT:', process.env.RAILWAY_ENVIRONMENT || 'not set');
console.log('   DATABASE_URL:', process.env.DATABASE_URL ? 'SET' : 'NOT SET');
console.log('   BOT_TOKEN:', process.env.BOT_TOKEN ? 'SET' : 'NOT SET');

// Now load dependencies
const { Telegraf, Markup } = require('telegraf');
const express = require('express');
const path = require('path');
const cors = require('cors');

// Create config AFTER environment check
const createConfig = require('../config/environment');
const config = createConfig();

console.log('🚀 Starting main app...');
console.log('🚀 Production mode - Using Railway environment variables');
console.log('🔧 Loading environment configuration...');
console.log('   Environment:', config.NODE_ENV);
console.log('   Platform:', config.IS_RAILWAY ? 'Railway 🚂' : 'Local');
console.log('   Port:', config.PORT);
console.log('✅ Running on Railway.com deployment');
const { connectDB } = require('../database/db');
const MiniBotManager = require('./services/MiniBotManager');

// Import handlers
const { startHandler, helpHandler, featuresHandler } = require('./handlers/startHandler');
const { createBotHandler, handleTokenInput, handleNameInput, cancelCreationHandler, isInCreationSession, getCreationStep } = require('./handlers/createBotHandler');
const { myBotsHandler } = require('./handlers/myBotsHandler');
const PlatformAdminHandler = require('./handlers/platformAdminHandler');
const WalletHandler = require('./handlers/walletHandler');

// Import routes
const walletRoutes = require('./routes/walletRoutes');

// Import cron jobs
const SubscriptionCron = require('./services/subscriptionCron');

// ==================== DYNAMIC URL HANDLING FOR RAILWAY ====================
const getRailwayPublicUrl = () => {
  // Helper function to clean URLs
  const cleanUrl = (url) => {
    if (!url) return url;
    
    let cleanUrl = url.toString().trim();
    
    // Remove any existing protocol
    cleanUrl = cleanUrl.replace(/^https?:\/\//i, '');
    
    // Remove trailing slash
    cleanUrl = cleanUrl.replace(/\/$/, '');
    
    // Add https://
    return `https://${cleanUrl}`;
  };

  // 1. DEVELOPMENT: Check for ngrok URL
  if (process.env.NGROK_URL) {
    const url = cleanUrl(process.env.NGROK_URL);
    console.log(`🔧 Development: Using NGROK_URL: ${url}`);
    return url;
  }
  
  // 2. Check for production Railway URL
  if (process.env.RAILWAY_STATIC_URL) {
    const url = cleanUrl(process.env.RAILWAY_STATIC_URL);
    console.log(`🚀 Production: Using RAILWAY_STATIC_URL: ${url}`);
    return url;
  }
  
  // 3. Check for PUBLIC_URL
  if (process.env.RAILWAY_PUBLIC_URL) {
    const url = cleanUrl(process.env.RAILWAY_PUBLIC_URL);
    console.log(`🚀 Production: Using RAILWAY_PUBLIC_URL: ${url}`);
    return url;
  }
  
  // 4. Check for SERVICE URL
  const serviceName = process.env.RAILWAY_SERVICE_NAME;
  const projectName = process.env.RAILWAY_PROJECT_NAME;
  
  if (serviceName && projectName) {
    const autoGeneratedUrl = `https://${serviceName}-${projectName}.up.railway.app`;
    console.log(`⚠️  WARNING: Using auto-generated service URL: ${autoGeneratedUrl}`);
    return autoGeneratedUrl;
  }
  
  // 5. DEVELOPMENT: Localhost fallback
  const isLocalDevelopment = !process.env.RAILWAY_ENVIRONMENT && 
                           (process.env.NODE_ENV === 'development' || !process.env.NODE_ENV);
  
  if (isLocalDevelopment) {
    console.log('🔧 Development: Local mode detected');
    return 'http://localhost:3000';
  }
  
  // 6. Fallback - use your custom domain
  const fallbackUrl = 'https://botomics.up.railway.app';
  console.log(`⚠️  No URL detected, using custom domain: ${fallbackUrl}`);
  return fallbackUrl;
};

const PUBLIC_URL = getRailwayPublicUrl();
console.log(`🌐 Public URL detected: ${PUBLIC_URL}`);

class MetaBotCreator {
  constructor() {
    console.log('\n🔍 Inside MetaBotCreator constructor...');
    console.log('BOT_TOKEN available:', !!process.env.BOT_TOKEN);
    console.log('DATABASE_URL available:', !!process.env.DATABASE_URL);
    console.log('ENCRYPTION_KEY available:', !!process.env.ENCRYPTION_KEY);
    
    // Check for variables
    const requiredVars = ['BOT_TOKEN', 'DATABASE_URL', 'ENCRYPTION_KEY'];
    const missingVars = requiredVars.filter(varName => !process.env[varName]);
    
    if (missingVars.length > 0) {
      console.error('\n❌ Missing required environment variables:', missingVars);
      console.error('\n⚠️  Railway might still be loading variables. Continuing anyway...');
    } else {
      console.log('✅ All required environment variables found!');
    }
    
    if (!process.env.BOT_TOKEN) {
      console.error('❌ BOT_TOKEN is not set in process.env');
    }
    
    console.log(`🤖 Creating bot instance...`);
    console.log(`🚀 Optimized for Railway.com deployment`);
    
    // Create config AFTER checking environment
    const createConfig = require('../config/environment');
    const config = createConfig();
    
    // Now create the bot with whatever token we have
    try {
      this.bot = new Telegraf(config.BOT_TOKEN || process.env.BOT_TOKEN, {
        handlerTimeout: 90000,
        telegram: {
          apiRoot: 'https://api.telegram.org',
          agent: null
        }
      });
    } catch (error) {
      console.error('❌ Failed to create Telegraf bot:', error.message);
    }
    
    this.expressApp = express();
    this.setupExpress();
    this.setupHandlers();
  }
  
  setupExpress() {
    console.log('🔄 Setting up Express server for Railway...');
    
    // Determine if running on Railway
    const isRailway = process.env.RAILWAY_ENVIRONMENT || 
                     process.env.RAILWAY_SERVICE_NAME || 
                     process.env.RAILWAY_PUBLIC_URL;
    
    console.log(`🚂 Running on Railway: ${isRailway ? 'Yes' : 'No'}`);
    console.log(`🌐 PUBLIC_URL: ${PUBLIC_URL}`);
    console.log(`📁 Current directory: ${process.cwd()}`);
    
    // ========== RAILWAY HEALTH CHECK ENDPOINT ==========
    this.expressApp.get('/health', (req, res) => {
      res.json({
        status: 'healthy',
        service: 'botomics-platform',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        environment: process.env.NODE_ENV || 'production'
      });
    });
    
    // Middleware
    this.expressApp.use(cors({
      origin: '*',
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
      allowedHeaders: ['Content-Type', 'Authorization', 'ngrok-skip-browser-warning']
    }));
    
    this.expressApp.use(express.json({ limit: '50mb' }));
    this.expressApp.use(express.urlencoded({ extended: true }));

    // Add favicon handler to prevent 404 errors
this.expressApp.get('/favicon.ico', (req, res) => {
    res.status(204).end(); // No content
});
    
    // Skip ngrok warnings
    this.expressApp.use((req, res, next) => {
      res.setHeader('ngrok-skip-browser-warning', 'true');
      next();
    });
    
    // Health check endpoint (for your API)
    this.expressApp.get('/api/health', (req, res) => {
      res.json({
        status: 'healthy',
        service: 'botomics-platform',
        version: '2.0.0',
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV || 'development',
        platform: isRailway ? 'railway' : 'local',
        publicUrl: PUBLIC_URL,
        walletUrl: `${PUBLIC_URL}/wallet`,
        railway: {
          environment: process.env.RAILWAY_ENVIRONMENT,
          serviceName: process.env.RAILWAY_SERVICE_NAME,
          publicUrl: process.env.RAILWAY_PUBLIC_URL
        }
      });
    });
    
    // Public URL endpoint
    this.expressApp.get('/api/public-url', (req, res) => {
      res.json({
        publicUrl: PUBLIC_URL,
        walletUrl: `${PUBLIC_URL}/wallet`,
        apiUrl: `${PUBLIC_URL}/api`,
        environment: process.env.NODE_ENV || 'development',
        timestamp: new Date().toISOString(),
        platform: isRailway ? 'railway' : 'local'
      });
    });
    
    // Wallet API routes
    this.expressApp.use('/api', walletRoutes);
    console.log('✅ Wallet API routes registered at /api');
    
    // ========== WALLET STATIC FILE SERVING ==========
    console.log('\n🔍 Looking for wallet directory...');
    
    const fs = require('fs');
    let walletPath;
    
    // Try multiple possible locations for wallet directory
    const possiblePaths = [
      // 1. Railway deployment path (most likely)
      path.join(process.cwd(), 'wallet'),
      
      // 2. Relative to current directory
      path.join(__dirname, '../../wallet'),
      
      // 3. Project root
      path.join(process.cwd(), '../wallet'),
      
      // 4. From src directory
      path.join(__dirname, '../wallet')
    ];
    
    // Find which path exists
    for (const possiblePath of possiblePaths) {
      console.log(`   Checking: ${possiblePath}`);
      if (fs.existsSync(possiblePath)) {
        walletPath = possiblePath;
        console.log(`   ✅ Found wallet at: ${walletPath}`);
        break;
      }
    }
    
    // If wallet not found, create it
    if (!walletPath) {
      console.log('❌ Wallet directory not found in any location!');
      console.log('📁 Creating wallet directory...');
      
      // Create wallet in current working directory
      walletPath = path.join(process.cwd(), 'wallet');
      fs.mkdirSync(walletPath, { recursive: true });
      
      // Create a simple index.html for testing
      const indexHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Botomics Wallet</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 20px;
            text-align: center;
            background: #f5f5f5;
        }
        .container {
            max-width: 500px;
            margin: 50px auto;
            padding: 30px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .logo {
            font-size: 48px;
            margin-bottom: 20px;
        }
        .status {
            color: #4CAF50;
            font-weight: bold;
            margin: 20px 0;
        }
        .info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">💰</div>
        <h1>Botomics Wallet</h1>
        <div class="status">✅ Online & Connected</div>
        
        <div class="info">
            <p><strong>URL:</strong> ${PUBLIC_URL}/wallet</p>
            <p><strong>Platform:</strong> ${isRailway ? 'Railway' : 'Local'}</p>
            <p><strong>Time:</strong> <span id="time">${new Date().toLocaleString()}</span></p>
            <p><strong>Public URL:</strong> ${PUBLIC_URL}</p>
        </div>
        
        <p>Open this from @BotomicsBot using /wallet command for full features.</p>
    </div>
    
    <script>
        // Update time every second
        setInterval(() => {
            document.getElementById('time').textContent = new Date().toLocaleString();
        }, 1000);
        
        // Check if running in Telegram
        if (window.Telegram && window.Telegram.WebApp) {
            console.log('Running in Telegram Web App');
            window.Telegram.WebApp.expand();
        } else {
            console.log('Running in browser');
        }
    </script>
</body>
</html>`;
      
      fs.writeFileSync(path.join(walletPath, 'index.html'), indexHtml);
      console.log('✅ Created basic wallet index.html');
    }
    
    // List files in wallet directory
    const walletFiles = fs.readdirSync(walletPath);
    console.log(`📁 Files in wallet directory (${walletFiles.length} files):`);
    walletFiles.forEach(file => console.log(`   - ${file}`));
    
    // Serve static files from wallet directory
    console.log(`📤 Serving static files from: ${walletPath}`);
    
    // Serve static files with proper headers
    this.expressApp.use('/wallet', express.static(walletPath, {
      setHeaders: (res, filePath) => {
        // Set CORS headers for static files
        res.set('Access-Control-Allow-Origin', '*');
        res.set('ngrok-skip-browser-warning', 'true');
        
        // Set proper MIME types
        if (filePath.endsWith('.js')) {
          res.set('Content-Type', 'application/javascript');
        } else if (filePath.endsWith('.css')) {
          res.set('Content-Type', 'text/css');
        } else if (filePath.endsWith('.html')) {
          res.set('Content-Type', 'text/html');
        }
        
        // Cache control
        if (isRailway) {
          res.set('Cache-Control', 'public, max-age=3600');
        }
      }
    }));
    
    // Handle /wallet route
    this.expressApp.get('/wallet', (req, res) => {
      console.log(`📥 GET /wallet from ${req.headers['user-agent']?.substring(0, 50) || 'unknown'}`);
      
      const indexPath = path.join(walletPath, 'index.html');
      
      if (fs.existsSync(indexPath)) {
        res.sendFile(indexPath);
      } else {
        res.status(200).send(`
          <!DOCTYPE html>
          <html>
          <head>
              <title>Botomics Wallet</title>
              <style>body { font-family: Arial; padding: 40px; text-align: center; }</style>
          </head>
          <body>
              <h1>💰 Botomics Wallet</h1>
              <p>Open from @BotomicsBot using /wallet command</p>
              <p><strong>Current URL:</strong> ${PUBLIC_URL}/wallet</p>
          </body>
          </html>
        `);
      }
    });
    
    // Handle /wallet/* paths for SPA routing
    this.expressApp.get('/wallet/*', (req, res) => {
      const indexPath = path.join(walletPath, 'index.html');
      
      if (fs.existsSync(indexPath)) {
        res.sendFile(indexPath);
      } else {
        res.status(404).send('Wallet not found');
      }
    });
    
    // Root route
    this.expressApp.get('/', (req, res) => {
      res.send(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Botomics Platform</title>
          <style>
            body { font-family: Arial; padding: 40px; max-width: 800px; margin: 0 auto; }
            .status { color: green; font-weight: bold; }
            .link-btn { display: inline-block; margin: 10px; padding: 12px 24px; background: #0088cc; color: white; text-decoration: none; border-radius: 8px; }
            .info-box { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
          </style>
        </head>
        <body>
          <h1>🤖 Botomics Platform</h1>
          <p class="status">✅ Online & Running</p>
          
          <div class="info-box">
            <h3>Quick Links</h3>
            <a href="/wallet" class="link-btn">💰 Open Wallet</a>
            <a href="/health" class="link-btn">📊 Railway Health</a>
            <a href="/api/health" class="link-btn">📊 API Health Check</a>
            <a href="/api/public-url" class="link-btn">🌐 URL Info</a>
            <a href="${PUBLIC_URL}/wallet" class="link-btn">🔗 Public Wallet</a>
          </div>
          
          <div class="info-box">
            <h3>Platform Info</h3>
            <p><strong>Environment:</strong> ${process.env.NODE_ENV || 'development'}</p>
            <p><strong>Public URL:</strong> ${PUBLIC_URL}</p>
            <p><strong>Wallet URL:</strong> ${PUBLIC_URL}/wallet</p>
            <p><strong>Platform:</strong> ${isRailway ? 'Railway 🚂' : 'Local 🖥️'}</p>
            <p><strong>Server Time:</strong> ${new Date().toISOString()}</p>
          </div>
        </body>
        </html>
      `);
    });
    
    // 404 handler
    this.expressApp.use((req, res) => {
      console.log(`❌ 404 Not Found: ${req.method} ${req.url}`);
      res.status(404).json({
        error: 'Not Found',
        message: `Route ${req.method} ${req.url} not found`,
        timestamp: new Date().toISOString(),
        publicUrl: PUBLIC_URL
      });
    });
    
    console.log('✅ Express server setup complete for Railway');
    console.log(`🌐 Wallet will be served at: ${PUBLIC_URL}/wallet`);
  }
  
  setupHandlers() {
    console.log('🔄 Setting up bot handlers...');
    
    this.setupMiniApp();
    
    // Global middleware for all updates
    this.bot.use(async (ctx, next) => {
      ctx.isMainBot = true;
      ctx.miniBotManager = this;
      
      if (PlatformAdminHandler.isPlatformCreator(ctx.from?.id)) {
        return next();
      }
      
      if (ctx.from && await PlatformAdminHandler.checkUserBan(ctx.from.id)) {
        await ctx.reply('🚫 Your account has been banned from using this platform.');
        return;
      }
      
      return next();
    });
    
    // Basic commands
    this.bot.start(startHandler);
    this.bot.help(helpHandler);
    this.bot.command('privacy', this.privacyHandler);
    this.bot.command('terms', this.termsHandler);
    
    // Wallet commands - FIXED: Use proper URL
    this.bot.command('wallet', async (ctx) => {
      await this.openWalletMiniApp(ctx);
    });
    
    this.bot.command('balance', async (ctx) => {
      await WalletHandler.handleWalletCommand(ctx);
    });
    
    this.bot.command('premium', async (ctx) => {
      await this.openWalletMiniApp(ctx, 'premium');
    });
    
    this.bot.command('subscription', async (ctx) => {
      await this.openWalletMiniApp(ctx, 'premium');
    });
    
    // Bot management commands
    this.bot.command('createbot', createBotHandler);
    this.bot.command('mybots', myBotsHandler);
    this.bot.command('cancel', cancelCreationHandler);
    
    // Platform admin commands
    this.bot.command('platform', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.platformDashboard(ctx);
      } else {
        ctx.reply('❌ Platform admin access required.');
      }
    });
    
    // Admin wallet commands
    this.bot.command('admin_wallet', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.walletAdminDashboard(ctx);
      } else {
        ctx.reply('❌ Admin access required.');
      }
    });
    
    this.bot.command('add_bom', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.startAddBOM(ctx);
      } else {
        ctx.reply('❌ Admin access required.');
      }
    });
    
    this.bot.command('freeze_wallet', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.startFreezeWallet(ctx);
      } else {
        ctx.reply('❌ Admin access required.');
      }
    });
    
    this.bot.command('unfreeze_wallet', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.startUnfreezeWallet(ctx);
      } else {
        ctx.reply('❌ Admin access required.');
      }
    });
    
    this.bot.command('grant_premium', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.startGrantPremium(ctx);
      } else {
        ctx.reply('❌ Admin access required.');
      }
    });
    
    this.bot.command('subscription_admin', async (ctx) => {
      if (PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await PlatformAdminHandler.subscriptionAdminDashboard(ctx);
      } else {
        ctx.reply('❌ Admin access required.');
      }
    });
    
    // Quick admin commands with arguments
    this.bot.command('addbom', async (ctx) => {
      if (!PlatformAdminHandler.isPlatformCreator(ctx.from.id)) {
        await ctx.reply('❌ Admin access required.');
        return;
      }
      
      const args = ctx.message.text.split(' ');
      if (args.length < 3) {
        await ctx.reply('Usage: /addbom <user_id> <amount>');
        await PlatformAdminHandler.startAddBOM(ctx);
        return;
      }
      
      // Quick add BOM with arguments
      try {
        const userIdentifier = args[1];
        const amount = parseFloat(args[2]);
        
        if (!amount || amount <= 0 || isNaN(amount)) {
          await ctx.reply('❌ Invalid amount. Please enter a positive number.');
          return;
        }
        
        // Find user
        let userId;
        if (isNaN(userIdentifier)) {
          const username = userIdentifier.replace('@', '').trim();
          const user = await require('./models').User.findOne({ where: { username: username } });
          if (!user) {
            await ctx.reply('❌ User not found. Please check the ID or username.');
            return;
          }
          userId = user.telegram_id;
        } else {
          userId = parseInt(userIdentifier);
        }
        
        const WalletService = require('./services/walletService');
        const result = await WalletService.adminAdjustBalance(
          userId, 
          amount, 
          'Quick admin BOM addition', 
          ctx.from.id
        );
        
        await ctx.reply(
          `✅ *BOM Added Successfully!*\n\n` +
          `*User ID:* ${userId}\n` +
          `*Amount Added:* ${amount.toFixed(2)} BOM\n` +
          `*New Balance:* ${result.newBalance.toFixed(2)} BOM\n` +
          `*Transaction ID:* ${result.transaction.id}`,
          { parse_mode: 'Markdown' }
        );
        
      } catch (error) {
        console.error('Quick add BOM error:', error);
        await ctx.reply(`❌ Error: ${error.message}`);
      }
    });
    
    // Debug and maintenance commands
    this.bot.command('debug_minibots', async (ctx) => {
      try {
        await ctx.reply('🔄 Debugging mini-bots...');
        const status = MiniBotManager.getInitializationStatus();
        let message = `🔍 *Mini-bot Debug Info*\n\n`;
        message += `*Status:* ${status.status}\n`;
        message += `*Initialized:* ${status.isInitialized ? 'Yes' : 'No'}\n`;
        message += `*Active Bots:* ${status.activeBots}\n`;
        
        const { Bot } = require('./models');
        const activeBots = await Bot.findAll({ where: { is_active: true } });
        message += `*Database Active Bots:* ${activeBots.length}\n`;
        
        await ctx.replyWithMarkdown(message);
      } catch (error) {
        console.error('Debug command error:', error);
        await ctx.reply('❌ Debug command failed.');
      }
    });
    
    this.bot.command('reinit', async (ctx) => {
      try {
        const userId = ctx.from.id;
        if (userId !== 1827785384) {
          await ctx.reply('❌ Only bot owner can use this command.');
          return;
        }
        await ctx.reply('🔄 Forcing reinitialization of all mini-bots...');
        const result = await MiniBotManager.forceReinitializeAllBots();
        await ctx.reply(`✅ Reinitialization completed. ${result} bots started.`);
      } catch (error) {
        console.error('Reinit command error:', error);
        await ctx.reply('❌ Error during reinitialization.');
      }
    });
    
    // Wallet debug command
    this.bot.command('wallet_debug', async (ctx) => {
      try {
        const userId = ctx.from.id;
        const balance = await require('./services/walletService').getBalance(userId);
        
        await ctx.replyWithMarkdown(
          `🔍 *Wallet Debug Info*\n\n` +
          `*User ID:* ${userId}\n` +
          `*Balance:* ${balance.balance.toFixed(2)} ${balance.currency}\n` +
          `*Status:* ${balance.isFrozen ? 'Frozen ❄️' : 'Active ✅'}\n` +
          `*Wallet Address:* BOTOMICS_${userId}\n\n` +
          `*Current Platform URL:* ${PUBLIC_URL}\n` +
          `*Wallet URL:* ${PUBLIC_URL}/wallet`
        );
      } catch (error) {
        console.error('Wallet debug error:', error);
        await ctx.reply(`❌ Debug error: ${error.message}`);
      }
    });
    
    // Railway URL command
    this.bot.command('railway_url', async (ctx) => {
      try {
        await ctx.replyWithMarkdown(
          `🌐 *Current Platform URLs*\n\n` +
          `*Public URL:* ${PUBLIC_URL}\n` +
          `*Wallet Mini-App:* ${PUBLIC_URL}/wallet\n` +
          `*API Base:* ${PUBLIC_URL}/api\n\n` +
          `*Save these URLs:*\n` +
          `• Wallet bookmark: ${PUBLIC_URL}/wallet\n` +
          `• Health check: ${PUBLIC_URL}/health\n` +
          `• Railway test: ${PUBLIC_URL}/api/health`
        );
      } catch (error) {
        console.error('Railway URL command error:', error);
        await ctx.reply(`❌ Error getting URLs: ${error.message}`);
      }
    });
    
    // Text message handler
    this.bot.on('text', async (ctx) => {
      const userId = ctx.from.id;
      const messageText = ctx.message.text;
      
      // Platform admin session (now includes wallet admin)
      if (PlatformAdminHandler.isInPlatformAdminSession(userId)) {
        await PlatformAdminHandler.handlePlatformAdminInput(ctx);
        return;
      }
      
      // Cancel creation
      if (messageText === '🚫 Cancel Creation') {
        await cancelCreationHandler(ctx);
        return;
      }
      
      // Bot creation session
      if (isInCreationSession(userId)) {
        const step = getCreationStep(userId);
        if (step === 'awaiting_token') {
          await handleTokenInput(ctx);
        } else if (step === 'awaiting_name') {
          await handleNameInput(ctx);
        }
        return;
      }
      
      // Quick actions via text
      if (messageText.toLowerCase() === 'wallet' || messageText === '💰 wallet') {
        await this.openWalletMiniApp(ctx);
        return;
      }
      
      if (messageText.toLowerCase() === 'premium' || messageText === '🎫 premium') {
        await this.openWalletMiniApp(ctx, 'premium');
        return;
      }
      
      if (messageText.toLowerCase() === 'balance' || messageText === '💰 balance') {
        await WalletHandler.handleWalletCommand(ctx);
        return;
      }
      
      if (messageText.toLowerCase() === 'railway' || messageText === '🚂 railway') {
        await ctx.replyWithMarkdown(
          `🚂 *Railway Platform Info*\n\n` +
          `*Current URL:* ${PUBLIC_URL}\n` +
          `*Wallet:* ${PUBLIC_URL}/wallet\n` +
          `*Environment:* ${process.env.RAILWAY_ENVIRONMENT || 'Production'}\n\n` +
          `URLs update automatically on redeployment.`
        );
        return;
      }
      
      // Admin quick access
      if (PlatformAdminHandler.isPlatformCreator(userId)) {
        if (messageText.toLowerCase() === 'admin' || messageText === '👑 admin') {
          await PlatformAdminHandler.platformDashboard(ctx);
          return;
        }
        
        if (messageText.toLowerCase() === 'admin wallet' || messageText === '🏦 admin wallet') {
          await PlatformAdminHandler.walletAdminDashboard(ctx);
          return;
        }
      }
      
      // Default to start handler
      await startHandler(ctx);
    });
    
    // Setup callback handlers
    this.setupCallbackHandlers();
    
    // Error handling
    this.bot.catch((err, ctx) => {
      console.error('❌ Main bot error:', err);
      try {
        ctx.reply('❌ An error occurred. Please try again.');
      } catch (e) {
        console.error('Failed to send error message:', e);
      }
    });
    
    console.log('✅ Main bot handlers setup complete');
  }

  setupMiniApp() {
    console.log('🔄 Setting up Mini App...');
    
    // Don't set menu button in localhost mode (it will fail)
    if (PUBLIC_URL.includes('localhost')) {
      console.log('⚠️  Skipping chat menu button in localhost mode (HTTPS required)');
      console.log('💡 Commands available: /wallet, /balance, /premium');
    } else {
      // Production or ngrok: Set up Web App
      const walletUrl = `${PUBLIC_URL}/wallet`;
      console.log(`📱 Mini App URL: ${walletUrl}`);
      
      this.bot.telegram.setChatMenuButton({
        menu_button: {
          type: 'web_app',
          text: '💰 Botomics Wallet',
          web_app: { url: walletUrl }
        }
      }).then(() => {
        console.log('✅ Chat menu button set successfully');
      }).catch(err => {
        console.warn('⚠️  Could not set menu button:', err.message);
        console.log('💡 This is normal in development or without bot permissions');
      });
      
      // Update the config for use in other handlers
      config.WALLET_URL = walletUrl;
    }
    
    // Handle web app data from mini-app
    this.bot.on('web_app_data', async (ctx) => {
      try {
        const data = JSON.parse(ctx.webAppData.data);
        console.log('📱 Mini App data received:', data.action);
        
        const userId = ctx.from.id;
        
        switch (data.action) {
          case 'get_balance':
            const walletService = require('./services/walletService');
            const balance = await walletService.getBalance(userId);
            await ctx.reply(
              `💰 *Your Wallet Balance*\n\n` +
              `*Balance:* ${balance.balance.toFixed(2)} ${balance.currency}\n` +
              `*Status:* ${balance.isFrozen ? '❄️ Frozen' : '✅ Active'}\n` +
              `*Address:* BOTOMICS_${userId}\n\n` +
              `*1 BOM = $1.00 USD*`,
              { parse_mode: 'Markdown' }
            );
            break;
            
          case 'get_public_url':
            await ctx.reply(
              `🌐 *Current Platform URL*\n\n` +
              `*Public URL:* ${PUBLIC_URL}\n` +
              `*Wallet URL:* ${config.WALLET_URL || `${PUBLIC_URL}/wallet`}\n` +
              `*API Base:* ${PUBLIC_URL}/api\n` +
              `*Environment:* ${process.env.NODE_ENV || 'production'}\n\n` +
              `Bookmark this for direct access to your wallet.`,
              { parse_mode: 'Markdown' }
            );
            break;
            
          case 'premium_upgrade':
            try {
              await require('./services/subscriptionService').upgradeToPremium(userId);
              await ctx.reply(
                '🎉 *Premium Subscription Activated!*\n\n' +
                'Your premium subscription has been successfully activated.\n\n' +
                '*Benefits:*\n' +
                '✅ Unlimited bot creation\n' +
                '✅ Unlimited broadcasts\n' +
                '✅ All premium features unlocked\n\n' +
                'Thank you for upgrading! 🚀',
                { parse_mode: 'Markdown' }
              );
            } catch (error) {
              await ctx.reply(`❌ Error: ${error.message}`);
            }
            break;
            
          case 'contact_support':
            await ctx.reply(
              '📞 *Botomics Support*\n\n' +
              'For assistance with:\n' +
              '• Buying BOM coins\n' +
              '• Wallet deposits/withdrawals\n' +
              '• Premium subscriptions\n' +
              '• Bot creation issues\n' +
              '• Technical problems\n\n' +
              'Contact: @BotomicsSupportBot\n\n' +
              'We typically respond within 24 hours.',
              { parse_mode: 'Markdown' }
            );
            break;
            
          default:
            await ctx.reply('✅ Action processed in wallet Mini App.');
        }
      } catch (error) {
        console.error('Mini App error:', error);
        await ctx.reply('❌ Mini App processing error. Please try again later.');
      }
    });
    
    console.log('✅ Mini App setup complete');
  }
  
  async openWalletMiniApp(ctx, section = 'main') {
    try {
      // Clean the URL properly
      let baseUrl = PUBLIC_URL;
      
      // Remove double protocols if any
      if (baseUrl.startsWith('https://https://')) {
        baseUrl = baseUrl.replace('https://https://', 'https://');
      }
      
      // Ensure it has a protocol
      if (!baseUrl.startsWith('https://') && !baseUrl.startsWith('http://')) {
        baseUrl = `https://${baseUrl}`;
      }
      
      const walletUrl = `${baseUrl}/wallet`;
      const fullUrl = section !== 'main' ? `${walletUrl}#${section}` : walletUrl;
      
      console.log(`🌐 Creating Web App button for Telegram`);
      console.log(`   Base URL: ${PUBLIC_URL}`);
      console.log(`   Cleaned URL: ${baseUrl}`);
      console.log(`   Wallet URL: ${fullUrl}`);
      console.log(`   User: ${ctx.from.id}`);
      
      const keyboard = Markup.inlineKeyboard([
        [Markup.button.webApp('🔓 Open Botomics Wallet', fullUrl)],
        [Markup.button.callback('📞 Support', 'contact_support')]
      ]);
      
      const message = 
        '💰 Botomics Wallet\n\n' +
        'Access your wallet:\n\n' +
        '1. Click "Open Botomics Wallet" button below\n' +
        '2. Use the Mini App inside Telegram\n' +
        '3. Manage balance, transactions, and premium\n\n' +
        `Your Wallet Address: BOTOMICS_${ctx.from.id}\n` +
        'To buy BOM coins: Contact @BotomicsSupportBot\n\n' +
        'Features:\n' +
        '• View balance & transaction history\n' +
        '• Deposit & withdraw BOM coins\n' +
        '• Transfer BOM to other users\n' +
        '• Manage premium subscription';

      await ctx.reply(message, keyboard);

    } catch (error) {
      console.error('❌ Open wallet error:', error);
      
      // Simple fallback
      try {
        const fallbackUrl = 'https://botomics.up.railway.app/wallet';
        await ctx.reply(
          '💰 Open your wallet by clicking the menu button below 👇',
          Markup.inlineKeyboard([
            [Markup.button.webApp('Open Wallet', fallbackUrl)]
          ])
        );
      } catch (fallbackError) {
        await ctx.reply('❌ Error opening wallet. Please try /balance command instead.');
      }
    }
  }
  
  setupCallbackHandlers() {
    console.log('🔄 Setting up main bot callback handlers...');
    
    // Register callbacks from handlers
    PlatformAdminHandler.registerCallbacks(this.bot);
    
    // Basic navigation
    this.bot.action('start', async (ctx) => {
      await ctx.answerCbQuery();
      await startHandler(ctx);
    });
    
    this.bot.action('create_bot', async (ctx) => {
      await ctx.answerCbQuery();
      await createBotHandler(ctx);
    });
    
    this.bot.action('my_bots', async (ctx) => {
      await ctx.answerCbQuery();
      await myBotsHandler(ctx);
    });
    
    this.bot.action('help', async (ctx) => {
      await ctx.answerCbQuery();
      await helpHandler(ctx);
    });
    
    this.bot.action('features', async (ctx) => {
      await ctx.answerCbQuery();
      await featuresHandler(ctx);
    });
    
    // Wallet callbacks
    this.bot.action('wallet_main', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleWalletCommand(ctx);
    });
    
    this.bot.action('wallet_deposit', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleDeposit(ctx);
    });
    
    this.bot.action('wallet_withdraw', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleWithdraw(ctx);
    });
    
    this.bot.action('wallet_transfer', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleTransfer(ctx);
    });
    
    this.bot.action('wallet_premium', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handlePremium(ctx);
    });
    
    this.bot.action('wallet_history', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleHistory(ctx, 0);
    });
    
    this.bot.action(/wallet_history_(\d+)/, async (ctx) => {
      const page = parseInt(ctx.match[1]);
      await ctx.answerCbQuery();
      await WalletHandler.handleHistory(ctx, page);
    });
    
    this.bot.action('wallet_upgrade_premium', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleUpgradePremium(ctx);
    });
    
    this.bot.action('wallet_cancel_premium', async (ctx) => {
      await ctx.answerCbQuery();
      await WalletHandler.handleCancelPremium(ctx);
    });
    
    // Railway and URL callbacks
    this.bot.action('get_public_url', async (ctx) => {
      await ctx.answerCbQuery();
      const walletUrl = config.WALLET_URL || `${PUBLIC_URL}/wallet`;
      
      await ctx.replyWithMarkdown(
        `🌐 *Current Platform URLs*\n\n` +
        `*Public URL:* ${PUBLIC_URL}\n` +
        `*Wallet Mini-App:* ${walletUrl}\n` +
        `*API Base:* ${PUBLIC_URL}/api\n\n` +
        `*Save these URLs:*\n` +
        `• Wallet bookmark: ${walletUrl}\n` +
        `• Health check: ${PUBLIC_URL}/health\n` +
        `• Railway test: ${PUBLIC_URL}/api/health`
      );
    });
    
    this.bot.action('railway_info', async (ctx) => {
      await ctx.answerCbQuery();
      await ctx.replyWithMarkdown(
        `🚂 *Railway Platform Info*\n\n` +
        `*Current URL:* ${PUBLIC_URL}\n` +
        `*Wallet:* ${PUBLIC_URL}/wallet\n` +
        `*API:* ${PUBLIC_URL}/api\n` +
        `*Environment:* ${process.env.RAILWAY_ENVIRONMENT || 'Production'}\n\n` +
        `*Auto-update:* URLs update on redeployment\n` +
        `*Mini-app:* Served from /wallet folder\n` +
        `*Database:* Railway PostgreSQL`
      );
    });
    
    // Support and info
    this.bot.action('buy_bom_info', async (ctx) => {
      await ctx.answerCbQuery();
      await ctx.reply(
        '💰 *Buy BOM Coins*\n\n' +
        'To purchase BOM coins:\n\n' +
        '1. Contact @BotomicsSupportBot\n' +
        '2. Specify amount you want to buy (minimum 5 BOM)\n' +
        '3. Follow payment instructions\n' +
        '4. Submit payment proof in wallet\n' +
        '5. Coins will be added after verification\n\n' +
        '*Rate:* 1 BOM = $1.00 USD\n' +
        '*Minimum Purchase:* 5 BOM ($5.00)\n\n' +
        '⚠️ *Only @BotomicsSupportBot is authorized to sell BOM coins*',
        { parse_mode: 'Markdown' }
      );
    });
    
    this.bot.action('contact_support', async (ctx) => {
      await ctx.answerCbQuery();
      await ctx.reply(
        '📞 *Botomics Support*\n\n' +
        'For assistance with:\n' +
        '• Buying BOM coins: Contact @BotomicsSupportBot\n' +
        '• Wallet deposits/withdrawals: Use Mini App\n' +
        '• Premium subscriptions: Use Mini App\n' +
        '• Bot creation issues: Use /help command\n' +
        '• Technical problems: Contact @BotomicsSupportBot\n\n' +
        'We typically respond within 24 hours.',
        {
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [{
                text: '🔙 Continue to Wallet',
                web_app: { url: `${PUBLIC_URL}/wallet` }
              }]
            ]
          }
        }
      );
    });

    // Terms and privacy
    this.bot.action('privacy_policy', async (ctx) => {
      await ctx.answerCbQuery();
      await this.privacyHandler(ctx);
    });
    
    this.bot.action('terms_of_service', async (ctx) => {
      await ctx.answerCbQuery();
      await this.termsHandler(ctx);
    });
    
    // Bot management callbacks
    this.bot.action(/bot_dashboard_(.+)/, async (ctx) => {
      const botId = ctx.match[1];
      const BotManagementHandler = require('./handlers/botManagementHandler').BotManagementHandler;
      await BotManagementHandler.handleBotDashboard(ctx, botId);
    });
    
    this.bot.action(/toggle_bot_(.+)/, async (ctx) => {
      const botId = ctx.match[1];
      const BotManagementHandler = require('./handlers/botManagementHandler').BotManagementHandler;
      await BotManagementHandler.handleToggleBot(ctx, botId);
    });
    
    this.bot.action(/delete_bot_(.+)/, async (ctx) => {
      const botId = ctx.match[1];
      const BotManagementHandler = require('./handlers/botManagementHandler').BotManagementHandler;
      await BotManagementHandler.handleDeleteBot(ctx, botId);
    });
    
    this.bot.action(/confirm_delete_(.+)/, async (ctx) => {
      const botId = ctx.match[1];
      const BotManagementHandler = require('./handlers/botManagementHandler').BotManagementHandler;
      await BotManagementHandler.handleConfirmDelete(ctx, botId);
    });
    
    // No-op for disabled buttons
    this.bot.action('noop', async (ctx) => {
      await ctx.answerCbQuery();
    });
    
    console.log('✅ Main bot callback handlers setup complete');
  }
  
  privacyHandler = async (ctx) => {
    try {
      const privacyMessage = `🔒 *Privacy Policy - Botomics*\n\n` +
        `*Last Updated: ${new Date().toISOString().split('T')[0]}*\n\n` +
        `*What Botomics Collect:*\n` +
        `• Basic Telegram profile info\n` +
        `• Wallet transaction data\n` +
        `• Bot creation and usage data\n` +
        `• Support communications\n\n` +
        `*How We Use Your Data:*\n` +
        `• To operate and maintain the Botomics platform\n` +
        `• To process wallet transactions\n` +
        `• To provide bot management features\n` +
        `• For customer support\n` +
        `• For service improvements\n\n` +
        `*Data Protection:*\n` +
        `• All data is encrypted at rest\n` +
        `• Database connections use SSL/TLS\n` +
        `• Regular security updates\n` +
        `• Access controls in place\n\n` +
        `*Your Rights:*\n` +
        `• Access your personal data\n` +
        `• Request data deletion\n` +
        `• Opt-out of communications\n\n` +
        `*Contact:*\n` +
        `Questions? Contact @BotomicsSupportBot\n\n` +
        `By using Botomics, you agree to our privacy practices.`;

      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('📋 Terms of Service', 'terms_of_service')],
        [Markup.button.callback('🔙 Main Menu', 'start')]
      ]);

      if (ctx.updateType === 'callback_query') {
        await ctx.editMessageText(privacyMessage, {
          parse_mode: 'Markdown',
          ...keyboard
        });
      } else {
        await ctx.replyWithMarkdown(privacyMessage, keyboard);
      }
    } catch (error) {
      console.error('Privacy handler error:', error);
      await ctx.reply(
        `🔒 Privacy Policy\n\n` +
        `We protect your data and only collect necessary information to provide our services.\n\n` +
        `Contact @BotomicsSupportBot for any concerns.`,
        Markup.inlineKeyboard([
          [Markup.button.callback('🔙 Main Menu', 'start')]
        ])
      );
    }
  }

  termsHandler = async (ctx) => {
    try {
      const termsMessage = `📋 *Terms of Service - Botomics*\n\n` +
        `*Last Updated: ${new Date().toISOString().split('T')[0]}*\n\n` +
        `*Acceptance of Terms:*\n` +
        `By using Botomics, you agree to these Terms of Service.\n\n` +
        `*Service Description:*\n` +
        `Botomics allows users to create and manage Telegram mini-bots with integrated wallet system.\n\n` +
        `*User Responsibilities:*\n` +
        `• You must own or have permission to use bot tokens\n` +
        `• You are responsible for your mini-bots' actions\n` +
        `• You must comply with Telegram's Terms of Service\n` +
        `• You must not use the service for illegal activities\n\n` +
        `*Wallet Terms:*\n` +
        `• 1 BOM = $1.00 USD fixed rate\n` +
        `• Minimum purchase: 5 BOM ($5.00)\n` +
        `• Minimum withdrawal: 20 BOM ($20.00)\n` +
        `• Processing times: 1-6 hours (deposits), 24 hours (withdrawals)\n` +
        `• Platform may freeze accounts for policy violations\n` +
        `• Only @BotomicsSupportBot is authorized to sell BOM coins\n\n` +
        `*Premium Subscription:*\n` +
        `• Price: 3 BOM per month or 30 BOM per year\n` +
        `• Auto-renewal enabled by default\n` +
        `• Cancel anytime, keep features until billing period ends\n\n` +
        `*Prohibited Uses:*\n` +
        `• Spamming, harassment, or abuse\n` +
        `• Illegal or fraudulent activities\n` +
        `• Money laundering or financial crimes\n` +
        `• Violating Telegram's Terms of Service\n\n` +
        `*Service Limitations:*\n` +
        `• Rate limiting applies to prevent abuse\n` +
        `• Features may change without notice\n` +
        `• Service availability not guaranteed\n\n` +
        `*Termination:*\n` +
        `We may suspend accounts for:\n` +
        `• Terms of Service violations\n` +
        `• Abuse of the service\n` +
        `• Illegal activities\n` +
        `• Fraudulent wallet activity\n\n` +
        `*Disclaimer:*\n` +
        `Service provided "as is" without warranties.\n\n` +
        `*Changes to Terms:*\n` +
        `We may update these terms with reasonable notice.\n\n` +
        `*Contact:*\n` +
        `Questions? Contact @BotomicsSupportBot\n\n` +
        `By using this service, you agree to these terms.`;

      const keyboard = Markup.inlineKeyboard([
        [Markup.button.callback('🔒 Privacy Policy', 'privacy_policy')],
        [Markup.button.callback('🔙 Main Menu', 'start')]
      ]);

      if (ctx.updateType === 'callback_query') {
        await ctx.editMessageText(termsMessage, {
          parse_mode: 'Markdown',
          ...keyboard
        });
      } else {
        await ctx.replyWithMarkdown(termsMessage, keyboard);
      }
    } catch (error) {
      console.error('Terms handler error:', error);
      await ctx.reply(
        `📋 Terms of Service\n\n` +
        `By using Botomics, you agree to use it responsibly and follow all platform rules.\n\n` +
        `Contact @BotomicsSupportBot for questions.`,
        Markup.inlineKeyboard([
          [Markup.button.callback('🔙 Main Menu', 'start')]
        ])
      );
    }
  }
  
  async initialize() {
    try {
      console.log('🔄 Starting MetaBot Creator initialization...');
      
      // First, wait a bit for Railway to inject variables
      console.log('⏳ Waiting for Railway environment variables...');
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Check if we have the required variables now
      const requiredVars = ['BOT_TOKEN', 'DATABASE_URL', 'ENCRYPTION_KEY'];
      const missingVars = requiredVars.filter(varName => !process.env[varName]);
      
      if (missingVars.length > 0) {
        console.error('❌ Still missing after wait:', missingVars);
        console.error('💡 Railway Variables might not be set correctly.');
        
        // Try to retry
        const success = await this.retryInitialization();
        if (!success) {
          console.error('❌ Cannot continue without environment variables.');
          return;
        }
      }
      
      console.log('✅ Environment variables confirmed');
      console.log('🗄️ Connecting to Railway PostgreSQL database...');
      
      // Now connect to database
      const { connectDB } = require('../database/db');
      await connectDB();
      
      // Import models AFTER connecting to database
      const models = require('./models');
      
      // Call associate methods for all models
      console.log('🔄 Setting up Sequelize associations...');
      Object.keys(models).forEach(modelName => {
        if (models[modelName] && models[modelName].associate) {
          try {
            models[modelName].associate(models);
            console.log(`✅ Associated: ${modelName}`);
          } catch (error) {
            console.error(`❌ Failed to associate ${modelName}:`, error.message);
          }
        }
      });
      console.log('✅ All Sequelize associations set up');
      
      // Update wallet schema if needed
      try {
        const { addWalletAddressField } = require('../../scripts/add_wallet_address');
        await addWalletAddressField();
        console.log('✅ Wallet schema updated');
      } catch (error) {
        console.log('⚠️  Wallet address script not found or failed, continuing...');
      }
      
      console.log('✅ MetaBot Creator initialized successfully');
    } catch (error) {
      console.error('❌ Initialization failed:', error);
    }
  }
  
  async retryInitialization() {
    try {
      console.log('🔄 Retrying initialization...');
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      const requiredVars = ['BOT_TOKEN', 'DATABASE_URL', 'ENCRYPTION_KEY'];
      const missingVars = requiredVars.filter(varName => !process.env[varName]);
      
      if (missingVars.length === 0) {
        console.log('✅ Variables loaded on retry!');
        return true;
      } else {
        console.error('❌ Still missing:', missingVars);
        return false;
      }
    } catch (error) {
      console.error('Retry initialization error:', error);
      return false;
    }
  }
  
  async start() {
    console.log('🚀 Starting MetaBot Creator on Railway...');
    
    try {
      const PORT = config.PORT;
      const HOST = config.HOST;
      
      // Calculate URLs based on current environment
      let walletUrl, apiUrl, publicUrlDisplay;
      
      if (PUBLIC_URL.includes('localhost')) {
        // Local development
        walletUrl = `http://${HOST}:${PORT}/wallet`;
        apiUrl = `http://${HOST}:${PORT}/api/health`;
        publicUrlDisplay = `http://${HOST}:${PORT} (Local)`;
      } else if (PUBLIC_URL.includes('ngrok.io')) {
        // ngrok tunnel
        walletUrl = `${PUBLIC_URL}/wallet`;
        apiUrl = `${PUBLIC_URL}/api/health`;
        publicUrlDisplay = `${PUBLIC_URL} (ngrok)`;
      } else {
        // Production (Railway)
        walletUrl = `${PUBLIC_URL}/wallet`;
        apiUrl = `${PUBLIC_URL}/api/health`;
        publicUrlDisplay = `${PUBLIC_URL} (Railway)`;
      }
      
      // Update config
      config.WALLET_URL = walletUrl;
      config.APP_URL = PUBLIC_URL;
      
      // Start Express server
      this.expressApp.listen(PORT, HOST, () => {
        console.log(`🌐 Express server running on ${HOST}:${PORT}`);
        console.log(`📱 Wallet: ${walletUrl}`);
        console.log(`⚡ API: ${apiUrl}`);
        console.log(`🚀 Railway Environment: ${process.env.RAILWAY_ENVIRONMENT || 'Not set'}`);
        console.log(`🌐 Public URL: ${publicUrlDisplay}`);
        console.log(`🔗 Local URL: http://localhost:${PORT}`);
      });
      
      // Wait a bit for server to start
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Start subscription auto-renewal cron jobs
      console.log('\n⏰ Starting subscription cron jobs...');
      SubscriptionCron.start();
      console.log('✅ Subscription auto-renewal system started');
      
      // Initialize mini-bots
      console.log('\n🚀 Starting mini-bots initialization...');
      const miniBotsResult = await MiniBotManager.initializeAllBots();
      console.log(`✅ ${miniBotsResult} mini-bots initialized`);
      
      // Start main Telegram bot
      console.log('\n🤖 Starting main Telegram bot...');
      await this.bot.launch({
        dropPendingUpdates: true,
        allowedUpdates: ['message', 'callback_query', 'web_app_data']
      });
      
      // Success message
      console.log('\n🎉 MetaBot Creator is now RUNNING on Railway!');
      console.log('===============================================');
      console.log('🚂 Platform: Railway');
      console.log('🌐 Public URL:', PUBLIC_URL);
      console.log('📱 Wallet URL:', PUBLIC_URL + '/wallet');
      console.log('🤖 Main Bot: Manages bot creation & wallet');
      console.log('🤖 Mini-bots: Handle user messages');
      console.log('💰 Botomics: Digital currency system');
      console.log('🎫 Premium: Subscription tiers (3 BOM/month)');
      console.log('⏰ Auto-renewal: Enabled (daily cron)');
      console.log('🏦 ADMIN WALLET COMMANDS (Platform Creator Only):');
      console.log('   /platform - Platform admin dashboard');
      console.log('   /admin_wallet - Wallet admin dashboard');
      console.log('   /add_bom - Add BOM to user');
      console.log('   /freeze_wallet - Freeze user wallet');
      console.log('   /unfreeze_wallet - Unfreeze user wallet');
      console.log('   /grant_premium - Grant premium subscription');
      console.log('   /subscription_admin - Subscription admin');
      console.log('   /addbom <user> <amount> - Quick add BOM');
      console.log('   /railway_url - Show current Railway URLs');
      console.log('===============================================');
      console.log(`🌐 Dashboard: ${PUBLIC_URL}`);
      console.log(`💰 Wallet: ${PUBLIC_URL}/wallet`);
      console.log(`💳 BOM Rate: 1 BOM = $1.00 USD`);
      
    } catch (error) {
      console.error('❌ Failed to start application:', error);
      console.error('Stack trace:', error.stack);
    }
    
    // Graceful shutdown
    process.once('SIGINT', () => this.shutdown());
    process.once('SIGTERM', () => this.shutdown());
  }
  
  async shutdown() {
    console.log('\n🛑 Shutting down gracefully on Railway...');
    
    if (this.bot) {
      await this.bot.stop();
      console.log('✅ Main bot stopped');
    }
    
    // Stop all mini-bots
    const activeBots = Array.from(MiniBotManager.activeBots.keys());
    console.log(`🔄 Stopping ${activeBots.length} mini-bots...`);
    
    for (const botId of activeBots) {
      try {
        await MiniBotManager.stopBot(botId);
      } catch (error) {
        console.error(`❌ Failed to stop mini-bot ${botId}:`, error);
      }
    }
    
    MiniBotManager.activeBots.clear();
    console.log('👋 All bots stopped');
    process.exit(0);
  }
}

// Start the application
async function startApplication() {
  try {
    console.log('🔧 Starting MetaBot Creator application on Railway...');
    
    const app = new MetaBotCreator();
    await app.initialize();
    await app.start();
    
    return app;
  } catch (error) {
    console.error('❌ Application failed to start:', error);
    setTimeout(() => process.exit(1), 5000);
  }
}

// Run if this file is executed directly
if (require.main === module) {
  startApplication();
}

// Export for testing/importing
module.exports = MetaBotCreator;